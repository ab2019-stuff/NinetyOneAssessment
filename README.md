# NinetyOneAssessment

Instructions: make sure you have the 'Code.py' and 'main.py' files along with the the txt file you would like to parse. To run the program simply go to the main class file and run in your IDE of choice. You will be prompted to enter the name of your chosen file you can enter this either in the form file or file.txt if the name is incorrect or the file cannot be found you will be asked to try again. Note that the provided Test input cases are given in the Test.txt text file provided so in order to check those simply run the program and type Test when prompted. The program will return a dictionary called 'Numbers' indexed by line number where the value corresponding to given key is a list containing the text versions of the numbers found in that list (this will be ['invalid number'] in the case of invalid or no numbers in the line of text.

Assumptions: This program can only read in text (i.e. .txt files). This code only deals with non negative integers it will assume decimals, fractions and negative numbers are invalid numbers same with comma seperated numbers e.g. 1,000 will return 'number invalid' but 1000 will return 'one thousand'. Furthermore if there is at least one invalid number on a line the data is deemed irreliable and so the program will just return['invalid number'] for the entire line. Numbers with leading 0's have the leading 0's removed before evaluations e.g 001 would be read as 'one and 0000000 would be read as 'zero' (as would 0);. An empty file will return an empty dictionary. The largest integers currently handled are those fot the order 10^52. All of these assumptions could be (relatively) easily removed. 

Design choices: abstraction: by using a seperate class to run the program by simply pressing run and typing in the required file name this program hides much of the behind the scenes complexity from the end user. Extendibility: given the recursive nature of this program it is easily extendible to even larger integers or to negative integers. Similarly for fractions and to a lesser extent decimals. Debugging/maintanence: This program splits up its main function into numerous smaller and easier to understand sub functions this is useful for ease of debugging and for making enhancements when necessary. Finally the error handling in the main class helps understandibility and user interactivity by providing guidance to the end user about where potential issues have come from instead of simply throwing an exception. 
